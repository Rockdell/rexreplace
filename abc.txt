RexReplace 5.1.4: Regexp search and replace for files using lookahead and
backreference to matching groups in the replacement. Defaults to global
multiline case-insensitive search.

> rexreplace pattern replacement [fileGlob|option]+

Options:
  -v, --version           Print rexreplace version (can be given as only
                          argument)                                    [boolean]
  -V, --verbose           More chatty output                           [boolean]
  -I, --void-ignore-case  Void case insensitive search pattern.        [boolean]
  -G, --void-global       Void global search (stop looking after the first
                          match).                                      [boolean]
  -s, --dot-all           Have `.` also match newline.                 [boolean]
  -M, --void-multiline    Void multiline search pattern. Makes ^ and $ match
                          start/end of whole content rather than each line.
                                                                       [boolean]
  -u, --unicode           Treat pattern as a sequence of unicode code points.
                                                                       [boolean]
  -e, --encoding          Encoding of files/piped data.        [default: "utf8"]
  -E, --engine            What regex engine to use:
                                          [choices: "V8", "RE2"] [default: "V8"]
  -q, --quiet             Only display errors (no other info)          [boolean]
  -Q, --quiet-total       Never display errors or info                 [boolean]
  -H, --halt              Halt on first error         [boolean] [default: false]
  -d, --debug             Print debug info                             [boolean]
  -€, --void-euro         Void having '€' as alias for '$' in pattern and
                          replacement parameters                       [boolean]
  -o, --output            Output the final result instead of saving to file.
                          Will also output content even if no replacement has
                          taken place.                                 [boolean]
  -A, --void-async        Handle files in a synchronous flow. Good to limit
                          memory usage when handling large files.      [boolean]
  -B, --void-backup       Avoid temporary backing up file. Works async
                          (independent of -A flag) and will speed up things but
                          at one point data lives only in memory, and you will
                          lose the content if the process is abrupted. [boolean]
  -b, --keep-backup       Keep a backup file of the original content.  [boolean]
  -m, --output-match      Output each match on a new line. Will not replace any
                          content but you still need to provide a dummy value
                          (like `_`) as replacement parameter. If search
                          pattern does not contain matching groups the full
                          match will be outputted. If search pattern does
                          contain matching groups only matching groups will be
                          outputted (same line with no delimiter).     [boolean]
  -T, --trim-pipe         Trim piped data before processing. If piped data only
                          consists of chars that can be trimmed (new line,
                          space, tabs...) it will become an empty string.
                                                                       [boolean]
  -R, --replacement-pipe  Replacement will be piped in. You still need to
                          provide a dummy value (like `_`) as replacement
                          parameter.                                   [boolean]
  -j, --replacement-js    Treat replacement as javascript source code.
                          The statement from the last expression will become
                          the replacement string.
                          Purposefully implemented the most insecure way
                          possible to remove _any_ incentive to consider
                          running code from an untrusted part.
                          The full match will be available as a javascript
                          variable named $0 while each captured group will be
                          available as $1, $2, $3, ... and so on.
                          At some point, the $ char _will_ give you a headache
                          when used from the command line, so use €0, €1, €2,
                          €3... instead.
                          If the javascript source code references to the full
                          match or a captured group the code will run once per
                          match. Otherwise, it will run once per file.

                          The code has access to the following variables:
                          `r` as an alias for `require` with both expanded to
                          understand a relative path even if it is not
                          starting with `./`,
                          `fs` from node,
                          `path` from node,
                          `globs` from npm,
                          `pipe`: the data piped into the command (null if no
                          piped data),
                          `find`: pattern searched for (the needle),
                          `text`: full text being searched i.e. file content
                          or piped data (the haystack),
                          `bytes`: total size of the haystack in bytes,
                          `size`: human-friendly representation of the total
                          size of the haystack,
                          `time`: String representing the local time when the
                          command was invoked,
                          `time_obj`: date object representing `time`,
                          `now`: alias for `time`,
                          `cwd`: current process working dir,
                          `nl`: a new-line char,
                          `_`: a single space char (for easy string
                          concatenation).

                          The following values defaults to `❌` if haystack
                          does not originate from a file:
                          `file`: contains the full path of the active file
                          being searched (including full filename),
                          `file_rel`: contains `file` relative to current
                          process working dir,
                          `dirpath`: contains the full path without filename
                          of the active file being searched,
                          `dirpath_rel`: contains `dirpath` relative to
                          current process working dir,
                          `filename`: is the full filename of the active file
                          being searched without path,
                          `name`: filename of the active file being searched
                          with no extension,
                          `ext`: extension of the filename including leading
                          dot,
                          `mtime`: ISO inspired representation of the last
                          local modification time of the current file,
                          `ctime`: ISO representation of the local creation
                          time of the current file.
                          `mtime_obj`: date object representing `mtime`,
                          `ctime_obj`: date object representing `ctime`.

                          All variables, except from module, date objects,
                          ´nl` and `_`, has a corresponding variable name
                          followed by `_` where the content has an extra space
                          at the end (for easy concatenation).
                                                                       [boolean]
  -h, --help              Display help.                                [boolean]

Examples:
  > rexreplace 'Foo' 'xxx' myfile.md        'foobar' in myfile.md will become
                                            'xxxbar'

  > rr Foo xxx myfile.md                    The alias 'rr' can be used instead
                                            of 'rexreplace'

  > rexreplace '(f?(o))o(.*)' '$3$1€2'      'foobar' in myfile.md will become
  myfile.md                                 'barfoo'

  > rexreplace '^#' '##' *.md               All markdown files in this dir got
                                            all headlines moved one level deeper

Inspiration: .oO(What should 'sed' have been by now?)
